{"version":3,"sources":["../../src/js/scroll_panel.js"],"names":["throttlePromise","isEqual","CONTAINER_STYLE","MATERIAL_STYLE","log_perf","html","DEBUG","BROWSER_MAX_HEIGHT","DOUBLE_BUFFER_RECREATE","DOUBLE_BUFFER_ROW","DOUBLE_BUFFER_COLUMN","DatagridVirtualTableViewModel","constructor","create_shadow_dom","attachShadow","mode","slot","shadowRoot","innerHTML","_virtual_scrolling_disabled","stick_container","document","createElement","scroll_container","children","virtual_panel","table_clip","table_staging","_sticky_container","_table_clip","_table_staging","_scroll_container","_virtual_panel","_calculate_viewport","nrows","reset_scroll_position","id","_view_cache","config","row_pivots","length","start_row","end_row","_calculate_row_range","start_col","end_col","_calculate_column_range","_nrows","height","_container_size","row_height","_column_sizes","header_levels","column_pivots","total_scroll_height","Math","max","offsetHeight","percent_scroll","scrollTop","virtual_panel_row_height","floor","relative_nrows","scroll_rows","round","total_scroll_width","offsetWidth","width","percent_left","scrollLeft","max_scroll_column","_max_scroll_column","table_model","num_columns","indices","column_paths","psp_offset","min","_validate_viewport","invalid_column","_start_col","invalid_row","_start_row","_end_row","_end_col","_needs_swap","_invalid_schema","_swap_in","args","table","parentElement","replaceChild","cloneNode","appendChild","_render_element","dispatchEvent","CustomEvent","bubbles","detail","_swap_out","_update_virtual_panel_width","invalid_schema","cidx","virtual_width","panel_width","style","_update_virtual_panel_height","virtual_panel_px_size","infer_options","Object","assign","old_config","draw","options","__debug_start_time__","performance","now","preserve_width","invalid_viewport","undefined","reset_scroll","view","num_rows","Infinity","viewport","swap_args","last_cells","_selected_id","autosize_cells"],"mappings":"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","sourcesContent":["/******************************************************************************\r\n *\r\n * Copyright (c) 2017, the Perspective Authors.\r\n *\r\n * This file is part of the Perspective library, distributed under the terms of\r\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\r\n *\r\n */\r\n\r\nimport {throttlePromise} from \"@finos/perspective-viewer/dist/esm/utils.js\";\r\n\r\nimport isEqual from \"lodash/isEqual\";\r\nimport CONTAINER_STYLE from \"../less/container.less\";\r\nimport MATERIAL_STYLE from \"../less/material.less\";\r\n\r\nimport {log_perf, html} from \"./utils\";\r\nimport {DEBUG, BROWSER_MAX_HEIGHT, DOUBLE_BUFFER_RECREATE, DOUBLE_BUFFER_ROW, DOUBLE_BUFFER_COLUMN} from \"./constants\";\r\n\r\n/**\r\n * Handles the virtual scroll pane, as well as the double buffering\r\n * of the underlying <table>. This DOM structure looks a little like\r\n * this:\r\n *\r\n *     +------------------------+      <- div.pd-scroll-container\r\n *     | +----------------------|------<- div.pd-virtual-panel\r\n *     | | +------------------+ |      <- div.pd-scroll-table-clip\r\n *     | | | +----------------|-|--+   <- table             |\r\n *     | | | | 1  A  Alabama  | |  |                        |\r\n *     | | | | 2  B  Arizona  | |  |                        |\r\n *     | | | | 3  C  Arkansas | |  |                        |\r\n *     | | | | 4  D  Californi| |  |                        |\r\n *     | | | | 5  E  Colorado | |  |                        |\r\n *     | | +------------------+ |  |                        |\r\n *     +------------------------+  |                        |\r\n *       |   | 8  H  District of C |                        |\r\n *       |   +---------------------+                        |\r\n *       |                                                  |\r\n *       |                                                  |\r\n *       |                                                  |\r\n *       |                                                  |\r\n *       |                                                  |\r\n *       +--------------------------------------------------+\r\n *\r\n * `overflow: auto` is applied to `.pd-scroll-container`, and `.pd-virtual-pane`\r\n * is sized to match the estimated \"virtual\" size of the `table`;  estimated,\r\n * because it's true size can't be known until all columns dimensions are known,\r\n * which may be deferred in the case of auto-sized tables.\r\n *\r\n * Double buffering can be enabled on \"column scroll\", \"row scroll\" and/or\r\n * \"column schema change\".  When enabled and a redraw is requested for the case,\r\n * the existing table is cloned with `cloneNode()` and swapped with the real\r\n * `table`, which is then updated offscreen and swapped back in.  While this is\r\n * much slower to render, it prevents draw-in.\r\n *\r\n * @class DatagridVirtualTableViewModel\r\n */\r\nexport class DatagridVirtualTableViewModel extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Create the DOM for this `shadowRoot`.\r\n     *\r\n     * `MATERIAL_STYLE` is needed both here, and in the document `<head>`, due\r\n     * to double buffering, which may read incorrect position/size values as the\r\n     * double buffered `<table>` is rendered in the shadow DOM before being\r\n     * swapped in.\r\n     *\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    create_shadow_dom() {\r\n        this.attachShadow({mode: \"open\"});\r\n        const slot = `<slot></slot>`;\r\n        this.shadowRoot.innerHTML = html`\r\n            <style>\r\n                ${CONTAINER_STYLE + MATERIAL_STYLE}\r\n            </style>\r\n            <div class=\"pd-scroll-container\">\r\n                <div class=\"pd-virtual-panel\">${this._virtual_scrolling_disabled && slot}</div>\r\n                <div class=\"pd-scroll-table-clip\">${this._virtual_scrolling_disabled || slot}</div>\r\n                <div style=\"position: absolute; visibility: hidden;\"></div>\r\n            </div>\r\n        `;\r\n\r\n        const stick_container = document.createElement(\"div\");\r\n        const [, scroll_container] = this.shadowRoot.children;\r\n        const [virtual_panel, table_clip, table_staging] = scroll_container.children;\r\n        this._sticky_container = stick_container;\r\n        this._table_clip = table_clip;\r\n        this._table_staging = table_staging;\r\n        this._scroll_container = scroll_container;\r\n        this._virtual_panel = virtual_panel;\r\n    }\r\n\r\n    /**\r\n     * Calculates the `viewport` argument for perspective's `to_columns` method.\r\n     *\r\n     * @param {*} nrows\r\n     * @param {*} reset_scroll_position\r\n     * @returns\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    _calculate_viewport(nrows, reset_scroll_position) {\r\n        const id = this._view_cache.config.row_pivots.length > 0;\r\n        if (this._virtual_scrolling_disabled) {\r\n            return {id};\r\n        }\r\n        const {start_row, end_row} = this._calculate_row_range(nrows, reset_scroll_position);\r\n        const {start_col, end_col} = this._calculate_column_range();\r\n        this._nrows = nrows;\r\n        return {start_col, end_col, start_row, end_row, id};\r\n    }\r\n\r\n    /**\r\n     * Calculate `start_row` and `end_row` for the viewport.  We do this by\r\n     * first calculating `total_scroll_height`, the px height of the\r\n     * scrollable page, from the `_virtual_panel.offsetHeight`.\r\n     *\r\n     *    0px +------------+-------------+  - virtual_panel.offsetHeight\r\n     *        |            |  .          |  . 600px\r\n     *        |  viewport  |  .          |  .\r\n     *        |            |  .          |  .\r\n     *  200px +------------+  - height   |  .  - total_scroll_height\r\n     *        |                 200px    |  .  . 400px\r\n     *        |                          |  .  .\r\n     *        |                          |  .  .\r\n     *        |                          |  .  .\r\n     *        |                          |  .  .\r\n     *  600px +--------------------------+  -  -\r\n     *\r\n     *  `percent_scroll` can be calculated from this value and `scrollTop`,\r\n     *  which we can then apply to the new calculated height to preserve scroll\r\n     *  position when the height has changed since previous render.\r\n     *\r\n     *    0px +--------------------------+  -\r\n     *        |                          |  .\r\n     *        |                          |  .\r\n     *        |                          |  . scrollable area\r\n     *  300px +------------+             |  .\r\n     *        |            |             |  .\r\n     *  - - - |  viewport  | - - - - - - |  - total_scroll_height\r\n     *        |            |             |    400px\r\n     *  500px +------------+             |\r\n     *        |                          |\r\n     *  600px +--------------------------+\r\n     *\r\n     * @param {*} nrows\r\n     * @param {*} reset_scroll_position\r\n     * @returns\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    _calculate_row_range(nrows, reset_scroll_position) {\r\n        const {height} = this._container_size;\r\n        const row_height = this._column_sizes.row_height || 19;\r\n        const header_levels = this._view_cache.config.column_pivots.length + 1;\r\n        const total_scroll_height = Math.max(1, this._virtual_panel.offsetHeight - this._scroll_container.offsetHeight);\r\n        const percent_scroll = this._scroll_container.scrollTop / total_scroll_height;\r\n        const virtual_panel_row_height = Math.floor(height / row_height);\r\n        const relative_nrows = !reset_scroll_position ? this._nrows || 0 : nrows;\r\n        const scroll_rows = Math.max(0, relative_nrows + (header_levels - virtual_panel_row_height));\r\n        let start_row = Math.round(scroll_rows * percent_scroll);\r\n        let end_row = start_row + virtual_panel_row_height;\r\n        return {start_row, end_row};\r\n    }\r\n\r\n    /**\r\n     * Calculates `start_col` and `end_col` for the viewport - most of the\r\n     * details of which are actually calculated in `_max_column`, the equivalent\r\n     * of `total_scroll_height` from `_calculate_row_range`.\r\n     *\r\n     * @returns\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    _calculate_column_range() {\r\n        const total_scroll_width = Math.max(1, this._virtual_panel.offsetWidth - this._container_size.width);\r\n        const percent_left = this._scroll_container.scrollLeft / total_scroll_width;\r\n        const max_scroll_column = this._max_scroll_column() + 0.5;\r\n        let start_col = Math.floor(max_scroll_column * percent_left);\r\n        let end_col = start_col + (this.table_model.num_columns() || 1) + 1;\r\n        return {start_col, end_col};\r\n    }\r\n\r\n    /**\r\n     * Calculates the minimum possible starting column index for which the last\r\n     * column is completely visible (e.g. not occluded by the container clip).\r\n     * This is assumed to be the # of columns unil the column widths are\r\n     * calculated as they are scrolled into view by the user, which requires\r\n     * special synchronization with _update_virtual_panel_width`\r\n     * as the scrollable width will changes as the user scrolls left to right.\r\n     *\r\n     * Once `_column_sizes.indices` has enough column widths populated from\r\n     * user scrolling, it calulates the cumulative sum of column widths from\r\n     * last visible column backwards, until the sum is larger than the viewport\r\n     * px width, which is 1 below the max scroll column\r\n     *\r\n     *               width = 290   = 210     = 100    = 0\r\n     *   0px               V       V         V        500px\r\n     *   +-----------------+-------+---------+--------+\r\n     *   | ..ol B) (Col C) | Col D | Col E   | Col F  |\r\n     *   |                 | 80px  | 110px   | 100px  |\r\n     *   |                 |       |         |        |\r\n     *\r\n     * @returns\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    _max_scroll_column() {\r\n        let width = 0;\r\n        if (this._view_cache.config.row_pivots.length > 0) {\r\n            width = this._column_sizes.indices[0];\r\n        }\r\n        let max_scroll_column = this._view_cache.column_paths.length;\r\n        while (width < this._container_size.width && max_scroll_column >= 0) {\r\n            max_scroll_column--;\r\n            width += this._column_sizes.indices[max_scroll_column] || 60;\r\n        }\r\n        const psp_offset = this._view_cache.config.row_pivots.length > 0;\r\n        return Math.min(this._view_cache.column_paths.length - (psp_offset ? 2 : 1), max_scroll_column + (psp_offset ? 0 : 1));\r\n    }\r\n\r\n    /**\r\n     * Determines whether the viewport is identical in row and column axes to\r\n     * the previous viewport rendered, for throttling identical render requests,\r\n     * e.g. when the logical (row-wise) viewport does not change, but the pixel\r\n     * viewport has moved a few px.\r\n     *\r\n     * @param {*} {start_col, end_col, start_row, end_row}\r\n     * @returns\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    _validate_viewport({start_col, end_col, start_row, end_row}) {\r\n        const invalid_column = this._start_col !== start_col;\r\n        const invalid_row = this._start_row !== start_row || this._end_row !== end_row || this._end_col !== end_col;\r\n        this._start_col = start_col;\r\n        this._end_col = end_col;\r\n        this._start_row = start_row;\r\n        this._end_row = end_row;\r\n        return {invalid_column, invalid_row};\r\n    }\r\n\r\n    /**\r\n     * A helper method to determine whether to perform a double-buffer render\r\n     * based on settings and render type.\r\n     *\r\n     * @param {*} {invalid_schema, invalid_row, invalid_column}\r\n     * @returns\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    _needs_swap({invalid_row, invalid_column}) {\r\n        return (DOUBLE_BUFFER_RECREATE && this._invalid_schema) || (DOUBLE_BUFFER_COLUMN && (invalid_column || this._invalid_schema)) || (DOUBLE_BUFFER_ROW && (invalid_row || this._invalid_schema));\r\n    }\r\n\r\n    /**\r\n     * Step 1 of a double-buffer render, swaps in a duplicate table and appends\r\n     * the real table to the hidden shadow DOM for mutation.\r\n     *\r\n     * @param {*} args\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    _swap_in(args) {\r\n        if (!this._virtual_scrolling_disabled) {\r\n            if (this._needs_swap(args)) {\r\n                if (this._sticky_container === this.table_model.table.parentElement) {\r\n                    this._sticky_container.replaceChild(this.table_model.table.cloneNode(true), this.table_model.table);\r\n                }\r\n                this._table_staging.appendChild(this.table_model.table);\r\n            } else {\r\n                if (this._sticky_container !== this.table_model.table.parentElement) {\r\n                    this._sticky_container.replaceChild(this.table_model.table, this._sticky_container.children[0]);\r\n                }\r\n            }\r\n        }\r\n        this._render_element.dispatchEvent(new CustomEvent(\"perspective-datagrid-before-update\", {bubbles: true, detail: this}));\r\n    }\r\n\r\n    /**\r\n     * Step 2 of a double-buffer render, swap the original table back into the\r\n     * light DOM.\r\n     *\r\n     * @param {*} args\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    _swap_out(args) {\r\n        if (!this._virtual_scrolling_disabled && this._needs_swap(args)) {\r\n            this._sticky_container.replaceChild(this.table_model.table, this._sticky_container.children[0]);\r\n        }\r\n        this._render_element.dispatchEvent(new CustomEvent(\"perspective-datagrid-after-update\", {bubbles: true, detail: this}));\r\n    }\r\n\r\n    /**\r\n     * Updates the `virtual_panel` width based on view state.\r\n     *\r\n     * @param {*} invalid_schema\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    _update_virtual_panel_width(invalid_schema) {\r\n        if (invalid_schema) {\r\n            const total_scroll_width = Math.max(1, this._virtual_panel.offsetWidth - this._container_size.width);\r\n            const percent_left = this._scroll_container.scrollLeft / total_scroll_width;\r\n            const max_scroll_column = this._max_scroll_column();\r\n            let cidx = 0,\r\n                virtual_width = 0;\r\n            while (cidx < max_scroll_column) {\r\n                virtual_width += this._column_sizes.indices[cidx] || 60;\r\n                cidx++;\r\n            }\r\n            const panel_width = this._container_size.width + virtual_width;\r\n            this._virtual_panel.style.width = panel_width + \"px\";\r\n            this._scroll_container.scrollLeft = percent_left * virtual_width;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the `virtual_panel` height based on the view state.\r\n     *\r\n     * @param {*} nrows\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    _update_virtual_panel_height(nrows) {\r\n        const {row_height = 19} = this._column_sizes;\r\n        const virtual_panel_px_size = Math.min(BROWSER_MAX_HEIGHT, nrows * row_height);\r\n        this._virtual_panel.style.height = `${virtual_panel_px_size}px`;\r\n    }\r\n\r\n    /**\r\n     * Infer options for `draw()` from the previous render state, given a new\r\n     * perspective `config`.\r\n     *\r\n     * @param {*} config\r\n     * @returns\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    infer_options(config) {\r\n        config = Object.assign({}, config);\r\n        if (!this._view_cache) {\r\n            return {};\r\n        }\r\n        const old_config = Object.assign({}, this._view_cache.config);\r\n        delete old_config[\"sort\"];\r\n        delete config[\"sort\"];\r\n        return {reset_scroll_position: !isEqual(config, old_config)};\r\n    }\r\n\r\n    /**\r\n     * Draws this virtual panel, given an object of render options that allow\r\n     * the implementor to fine tune the individual render frames based on the\r\n     * interaction and previous render state.\r\n     *\r\n     * `reset_scroll_position` will not prevent the viewport from moving as\r\n     * `draw()` may change the dmiensions of the virtual_panel (and thus,\r\n     * absolute scroll offset).  This calls `reset_scroll`, which will\r\n     * trigger `_on_scroll` and ultimately `draw()` again;  however, this call\r\n     * to `draw()` will be for the same viewport and will not actually cause\r\n     * a render.\r\n     *\r\n     * @param {*} [options={reset_scroll_position = false, preserve_width = false, invalid_viewport = false}]\r\n     * @returns\r\n     * @memberof DatagridVirtualTableViewModel\r\n     */\r\n    @throttlePromise\r\n    async draw(options = {}) {\r\n        const __debug_start_time__ = DEBUG && performance.now();\r\n        const {reset_scroll_position = false, preserve_width = false, invalid_viewport = false} = options;\r\n\r\n        if (this._view_cache.column_paths === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (reset_scroll_position) {\r\n            this.reset_scroll();\r\n        }\r\n\r\n        const nrows = await this._view_cache.view.num_rows();\r\n\r\n        if (this._virtual_scrolling_disabled) {\r\n            this._container_size = {width: Infinity, height: Infinity};\r\n        } else {\r\n            this._container_size = (!this._invalid_schema && this._container_size) || {\r\n                width: this._sticky_container.offsetWidth,\r\n                height: this._sticky_container.offsetHeight\r\n            };\r\n        }\r\n\r\n        const viewport = this._calculate_viewport(nrows, reset_scroll_position);\r\n        const swap_args = this._validate_viewport(viewport);\r\n        const {invalid_row, invalid_column} = swap_args;\r\n        this._update_virtual_panel_height(nrows);\r\n\r\n        if (this._invalid_schema || invalid_row || invalid_column || invalid_viewport) {\r\n            this._swap_in(swap_args);\r\n            const last_cells = await this.table_model.draw(this._container_size, this._view_cache, this._selected_id, preserve_width, viewport);\r\n            this._swap_out(swap_args);\r\n            this.table_model.autosize_cells(last_cells);\r\n            if (!preserve_width) {\r\n                this._update_virtual_panel_width(this._invalid_schema || invalid_column || invalid_viewport);\r\n            }\r\n            this._invalid_schema = false;\r\n        }\r\n\r\n        if (DEBUG) {\r\n            log_perf(performance.now() - __debug_start_time__);\r\n        }\r\n    }\r\n}\r\n"],"file":"scroll_panel.js"}