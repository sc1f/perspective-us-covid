{"version":3,"sources":["../../../src/js/data_accessor/index.js"],"names":["DateParser","is_valid_date","get_column_type","get_type_config","DataAccessor","constructor","data_formats","row","column","schema","format","undefined","data","names","types","row_count","date_parsers","date_validator","val","is_format","Array","isArray","Object","keys","JSON","stringify","count_rows","length","get_format","get","column_name","row_index","value","d","hasOwnProperty","marshal","column_index","type","clean_data","date_parser","Number","toLowerCase","parse","clean","init","overridden_types","name","new_type","console","debug"],"mappings":"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","sourcesContent":["/******************************************************************************\n *\n * Copyright (c) 2018, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\n\nimport {DateParser, is_valid_date} from \"./date_parser.js\";\nimport {get_column_type} from \"../utils.js\";\nimport {get_type_config} from \"../config/index.js\";\n\nexport class DataAccessor {\n    constructor() {\n        this.data_formats = {\n            row: 0,\n            column: 1,\n            schema: 2\n        };\n        this.format = undefined;\n        this.data = undefined;\n        this.names = undefined;\n        this.types = undefined;\n        this.row_count = undefined;\n        this.date_parsers = {};\n        this.date_validator = val => is_valid_date(val);\n    }\n\n    is_format(data) {\n        if (Array.isArray(data)) {\n            return this.data_formats.row;\n        } else if (Array.isArray(data[Object.keys(data)[0]])) {\n            return this.data_formats.column;\n        } else if (typeof data[Object.keys(data)[0]] === \"string\" || typeof data[Object.keys(data)[0]] === \"function\") {\n            return this.data_formats.schema;\n        } else {\n            throw `Could not determine data format for ${JSON.stringify(data)}, with JS typeof ${typeof data}`;\n        }\n    }\n\n    count_rows(data) {\n        if (this.format === this.data_formats.row) {\n            return data.length;\n        } else if (this.format === this.data_formats.column) {\n            return data[Object.keys(data)[0]].length;\n        } else {\n            return 0;\n        }\n    }\n\n    get_format() {\n        return this.format;\n    }\n\n    get(column_name, row_index) {\n        let value = undefined;\n\n        if (this.format === this.data_formats.row) {\n            let d = this.data[row_index];\n            if (d.hasOwnProperty(column_name)) {\n                value = d[column_name];\n            }\n        } else if (this.format === this.data_formats.column) {\n            if (this.data.hasOwnProperty(column_name)) {\n                value = this.data[column_name][row_index];\n            }\n        } else if (this.format === this.data_formats.schema) {\n            value = undefined;\n        } else {\n            throw `Could not get() from dataset - ${this.data} is poorly formatted.`;\n        }\n\n        return value;\n    }\n\n    marshal(column_index, row_index, type) {\n        const column_name = this.names[column_index];\n        let val = clean_data(this.get(column_name, row_index));\n        let date_parser;\n\n        if (val === null) {\n            return null;\n        }\n\n        if (typeof val === \"undefined\") {\n            return undefined;\n        }\n\n        if (this.date_parsers[column_name] === undefined) {\n            this.date_parsers[column_name] = new DateParser();\n        }\n\n        date_parser = this.date_parsers[column_name];\n\n        switch (get_column_type(type.value)) {\n            case \"float\":\n            case \"integer\": {\n                val = Number(val);\n                break;\n            }\n            case \"boolean\": {\n                if (typeof val === \"string\") {\n                    val.toLowerCase() === \"true\" ? (val = true) : (val = false);\n                } else {\n                    val = !!val;\n                }\n                break;\n            }\n            case \"datetime\":\n            case \"date\": {\n                val = date_parser.parse(val);\n                break;\n            }\n            default: {\n                val += \"\"; // TODO this is not right - might not be a string.  Need a data cleaner\n            }\n        }\n\n        return val;\n    }\n\n    /**\n     * Resets the internal state of the accessor, preventing collisions with\n     * previously set data.\n     *\n     * @private\n     */\n    clean() {\n        this.date_parsers = {};\n        this.names = undefined;\n        this.types = undefined;\n    }\n\n    /**\n     * Links the accessor to a package of data for processing, calculating its\n     * format and size.\n     *\n     * @private\n     * @param {object} data\n     *\n     * @returns An object with 5 properties:\n     *    cdata - an array of columnar data.\n     *    names - the column names.\n     *    types - the column t_dtypes.\n     *    row_count - the number of rows per column.\n     *    is_arrow - an internal flag marking arrow-formatted data\n     */\n    init(data) {\n        this.data = data;\n        this.format = this.is_format(this.data);\n        this.row_count = this.count_rows(this.data);\n        const overridden_types = {};\n        if (this.format === this.data_formats.row) {\n            if (data.length > 0) {\n                this.names = Object.keys(data[0]);\n            } else {\n                this.clean.names = [];\n            }\n        } else if (this.format === this.data_formats.column) {\n            this.names = Object.keys(data);\n        } else if (this.format === this.data_formats.schema) {\n            this.names = Object.keys(data);\n            for (const name of this.names) {\n                const new_type = get_type_config(data[name]);\n                if (new_type.type) {\n                    console.debug(`Converting \"${data[name]}\" to \"${new_type.type}\"`);\n                    overridden_types[name] = data[name];\n                    data[name] = new_type.type;\n                }\n            }\n        } else {\n            throw `Could not initialize - failed to determine format for ${data}`;\n        }\n        return overridden_types;\n    }\n}\n\n/**\n * Coerce string null into value null.\n * @private\n * @param {*} value\n */\nexport function clean_data(value) {\n    if (value === null || value === \"null\") {\n        return null;\n    } else if (value === undefined || value === \"undefined\") {\n        return undefined;\n    } else {\n        return value;\n    }\n}\n"],"file":"index.js"}