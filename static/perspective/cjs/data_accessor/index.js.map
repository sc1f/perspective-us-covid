{"version":3,"sources":["../../../src/js/data_accessor/index.js"],"names":["constructor","row","column","schema","val","is_valid_date","is_format","Array","data","Object","JSON","count_rows","get_format","get","value","d","marshal","column_name","clean_data","date_parser","get_column_type","type","Number","clean","init","overridden_types","new_type","get_type_config","console"],"mappings":"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","sourcesContent":["/******************************************************************************\n *\n * Copyright (c) 2018, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\n\nimport {DateParser, is_valid_date} from \"./date_parser.js\";\nimport {get_column_type} from \"../utils.js\";\nimport {get_type_config} from \"../config/index.js\";\n\nexport class DataAccessor {\n    constructor() {\n        this.data_formats = {\n            row: 0,\n            column: 1,\n            schema: 2\n        };\n        this.format = undefined;\n        this.data = undefined;\n        this.names = undefined;\n        this.types = undefined;\n        this.row_count = undefined;\n        this.date_parsers = {};\n        this.date_validator = val => is_valid_date(val);\n    }\n\n    is_format(data) {\n        if (Array.isArray(data)) {\n            return this.data_formats.row;\n        } else if (Array.isArray(data[Object.keys(data)[0]])) {\n            return this.data_formats.column;\n        } else if (typeof data[Object.keys(data)[0]] === \"string\" || typeof data[Object.keys(data)[0]] === \"function\") {\n            return this.data_formats.schema;\n        } else {\n            throw `Could not determine data format for ${JSON.stringify(data)}, with JS typeof ${typeof data}`;\n        }\n    }\n\n    count_rows(data) {\n        if (this.format === this.data_formats.row) {\n            return data.length;\n        } else if (this.format === this.data_formats.column) {\n            return data[Object.keys(data)[0]].length;\n        } else {\n            return 0;\n        }\n    }\n\n    get_format() {\n        return this.format;\n    }\n\n    get(column_name, row_index) {\n        let value = undefined;\n\n        if (this.format === this.data_formats.row) {\n            let d = this.data[row_index];\n            if (d.hasOwnProperty(column_name)) {\n                value = d[column_name];\n            }\n        } else if (this.format === this.data_formats.column) {\n            if (this.data.hasOwnProperty(column_name)) {\n                value = this.data[column_name][row_index];\n            }\n        } else if (this.format === this.data_formats.schema) {\n            value = undefined;\n        } else {\n            throw `Could not get() from dataset - ${this.data} is poorly formatted.`;\n        }\n\n        return value;\n    }\n\n    marshal(column_index, row_index, type) {\n        const column_name = this.names[column_index];\n        let val = clean_data(this.get(column_name, row_index));\n        let date_parser;\n\n        if (val === null) {\n            return null;\n        }\n\n        if (typeof val === \"undefined\") {\n            return undefined;\n        }\n\n        if (this.date_parsers[column_name] === undefined) {\n            this.date_parsers[column_name] = new DateParser();\n        }\n\n        date_parser = this.date_parsers[column_name];\n\n        switch (get_column_type(type.value)) {\n            case \"float\":\n            case \"integer\": {\n                val = Number(val);\n                break;\n            }\n            case \"boolean\": {\n                if (typeof val === \"string\") {\n                    val.toLowerCase() === \"true\" ? (val = true) : (val = false);\n                } else {\n                    val = !!val;\n                }\n                break;\n            }\n            case \"datetime\":\n            case \"date\": {\n                val = date_parser.parse(val);\n                break;\n            }\n            default: {\n                val += \"\"; // TODO this is not right - might not be a string.  Need a data cleaner\n            }\n        }\n\n        return val;\n    }\n\n    /**\n     * Resets the internal state of the accessor, preventing collisions with\n     * previously set data.\n     *\n     * @private\n     */\n    clean() {\n        this.date_parsers = {};\n        this.names = undefined;\n        this.types = undefined;\n    }\n\n    /**\n     * Links the accessor to a package of data for processing, calculating its\n     * format and size.\n     *\n     * @private\n     * @param {object} data\n     *\n     * @returns An object with 5 properties:\n     *    cdata - an array of columnar data.\n     *    names - the column names.\n     *    types - the column t_dtypes.\n     *    row_count - the number of rows per column.\n     *    is_arrow - an internal flag marking arrow-formatted data\n     */\n    init(data) {\n        this.data = data;\n        this.format = this.is_format(this.data);\n        this.row_count = this.count_rows(this.data);\n        const overridden_types = {};\n        if (this.format === this.data_formats.row) {\n            if (data.length > 0) {\n                this.names = Object.keys(data[0]);\n            } else {\n                this.clean.names = [];\n            }\n        } else if (this.format === this.data_formats.column) {\n            this.names = Object.keys(data);\n        } else if (this.format === this.data_formats.schema) {\n            this.names = Object.keys(data);\n            for (const name of this.names) {\n                const new_type = get_type_config(data[name]);\n                if (new_type.type) {\n                    console.debug(`Converting \"${data[name]}\" to \"${new_type.type}\"`);\n                    overridden_types[name] = data[name];\n                    data[name] = new_type.type;\n                }\n            }\n        } else {\n            throw `Could not initialize - failed to determine format for ${data}`;\n        }\n        return overridden_types;\n    }\n}\n\n/**\n * Coerce string null into value null.\n * @private\n * @param {*} value\n */\nexport function clean_data(value) {\n    if (value === null || value === \"null\") {\n        return null;\n    } else if (value === undefined || value === \"undefined\") {\n        return undefined;\n    } else {\n        return value;\n    }\n}\n"],"file":"index.js"}