{"version":3,"sources":["../../../src/js/computed_expressions/error.js"],"names":["token_name_to_display_name","columnName","leftParen","rightParen","add","subtract","multiply","divide","percent_of","actual_token_to_string","token","actual","Array","isArray","filter","x","tokenType","name","map","payload","image","length","PerspectiveLexerErrorMessage","buildUnexpectedCharactersMessage","fullText","startOffset","line","column","PerspectiveParserErrorMessage","buildEarlyExitMessage","options","expected_path_names","expectedIterationPaths","expected","path","push","join","buildMismatchTokenMessage","message","buildNoViableAltMessage","ruleName"],"mappings":"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","sourcesContent":["/******************************************************************************\n *\n * Copyright (c) 2017, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\nconst token_name_to_display_name = {\n    columnName: \"column name\",\n    leftParen: \"(\",\n    rightParen: \")\",\n    add: \"+\",\n    subtract: \"-\",\n    multiply: \"*\",\n    divide: \"/\",\n    percent_of: \"%\"\n};\n\nconst actual_token_to_string = token => {\n    let actual;\n    if (Array.isArray(token)) {\n        actual = token\n            .filter(x => x.tokenType.name !== \"EOF\")\n            .map(x => {\n                if (x.payload) {\n                    return x.payload;\n                } else {\n                    return x.image;\n                }\n            });\n    } else {\n        actual = token.payload ? token.payload : token.image;\n    }\n\n    if (!actual || actual.length === 0) {\n        actual = \"EOF\";\n    }\n\n    return actual;\n};\n\n/**\n * A custom error message provider for the Lexer.\n */\nexport const PerspectiveLexerErrorMessage = {\n    /**\n     * Builds an error message to be displayed when the Lexer finds an\n     * unexpected character that cannot be matched.\n     *\n     * @param {*} fullText\n     * @param {*} startOffset\n     * @param {*} length\n     * @param {*} line\n     * @param {*} column\n     */\n    buildUnexpectedCharactersMessage: (fullText, startOffset, length, line, column) => {\n        return `Ln ${line}, Col ${column}: Unexpected input \\`${fullText}\\` at character ${startOffset}`;\n    }\n};\n\nexport const PerspectiveParserErrorMessage = {\n    /**\n     * Build an error message for when the parser is missing a mandatory token\n     * in a repetition, i.e. `pow2` is a function name, but it requires a `(`\n     * or column name to be syntactically correct.\n     */\n    buildEarlyExitMessage: options => {\n        let actual = actual_token_to_string(options.actual);\n\n        // A 2-dimensional array of expected paths\n        const expected_path_names = options.expectedIterationPaths.map(expected => {\n            let path = [];\n            expected.map(x => {\n                const name = \" - \" + token_name_to_display_name[x.name] ? token_name_to_display_name[x.name] : x.name;\n                path.push(name);\n            });\n            return path.join(\", \");\n        });\n        return `Unexpected token: \\`${actual}\\`\\n\\nExpected one of the following tokens: \\n ${expected_path_names.join(\"\\n\")}`;\n    },\n\n    /**\n     * Build an error message for when a token is mismatched, i.e. an opening\n     * parenthesis without a matching closing parenthesis.\n     */\n    buildMismatchTokenMessage: options => {\n        let actual = actual_token_to_string(options.actual);\n\n        let expected = options.expected.name;\n\n        if (token_name_to_display_name[expected]) {\n            expected = token_name_to_display_name[expected];\n        }\n\n        let message = `Expecting token \\`${expected}\\`, but found \\`${actual}\\`.`;\n\n        if (expected === \")\" || expected === \"rightParen\") {\n            message += \"\\n\\nMake sure all left parentheses are matched\\nwith right parentheses.\";\n        }\n\n        return message;\n    },\n\n    /**\n     * Build an error message for when a token does not fit into the grammar,\n     * i.e. if the expression does not begin with a column name, `(`, or\n     * any of the functional operators.\n     */\n    buildNoViableAltMessage: options => {\n        let actual = actual_token_to_string(options.actual);\n        let message = `Unexpected token: \\`${actual}\\`.`;\n\n        if (options.ruleName === \"Expression\") {\n            message += `\\n\\nExpected a column name, \\`(\\`,\\nor functional operator such as:\\n- \\`sqrt\\`\\n- \\`uppercase\\`\\n- \\`day_of_week\\``;\n        } else if (options.ruleName === \"ColumnName\") {\n            message += `\\n\\nExpected a column name or \\`(\\``;\n        } else if (options.ruleName === \"TerminalColumnName\") {\n            message += `\\n\\nExpected a column name after 'AS'`;\n        }\n\n        return message;\n    }\n};\n"],"file":"error.js"}